<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
		<head>
				<title>Firera tutorial</title>
				<meta charset="UTF-8">
				<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<link rel="stylesheet" href="guide.css" />
				<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css">
				<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
				<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
				<style>
					#content > * {
						padding: 50px 40px 40px 66px;
						background-color: white;
						margin-top: 3em;
						margin-bottom: 3em;
					}
					
						html {
							/*min-height: 100%;
							background-color: #b7d1e4;*/
						}
						
						.exp {
							width: 100%;
							background-color: white;
							border-top: 1px solid #b7d1e4;
							border-bottom: 1px solid #b7d1e4;
							margin-top: 50px;
						}
						
						.sub-exp {
							max-width: 800px;
							margin: auto;
						}
						.sub-exp > ul {
							margin: 0px;
							padding-left: 120px;
						}
						.sub-exp > ul > li a {
							color: black;
							text-decoration: none;
						}
						.sub-exp > ul > li {
							float: right;
							list-style: none;
							width: 167px;
							text-align: center;
							height: 20px;
							padding-top: 60px;
						}
						
						.titl a {
							color: white;
							text-decoration: none;
							font-style: italic;
						}
						
						.titl {
							width: 120px;
							text-align: center;
							background-color: #b7d1e4;
							color: white;
							text-transform: uppercase;
							padding: 30px 0px;
							font-size: 15px;
							line-height: 15px;
						}
						
						body {
							margin: 0px;
						}
				</style>
		</head>
		<body>
				<div class="to-main">
						<a href="index.html">
								<span style="font-size:11px">&larr;</span> &nbsp;&nbsp;to main page
						</a>
				</div>
			<!--<div class="exp">
				<div class="sub-exp">
					<ul>
						<li>
							Discussion
						</li>
						<li>
							Repo
						</li>
						<li>
							<a href="install.html">Install</a>
						</li>
						<li>
							<a href="guide.html">Tutorial</a>
						</li>
					</ul>
					<div class="titl">
						<a href="index.html">Firera -
						Javascript
						Functional
						Reactive
						Declarative
						Framework</a>
					</div>
				</div>-->
				
				<div id="content">
				<div>
				<h1>Firera tutorial</h1>
				<hr>
				<h2>Getting started: declarative FRP</h2>
				<div>Let's start with a simple example:</div>
<code>
const base = {
	a: 10,
	b: 20,
	c: [(n, m) => n + m, 'a', 'b']
}
// Create a Firera app instance
const app = Firera({
	__root: base
})
app.get('c'); // 30

// Here comes a FRP magic
app.set('b', 32);
app.get('c'); // 42
</code>
	<div>
		This is a simple example for introducing functional reactive programming priciples.
		Here 'a' and 'b' are <b>observable</b> values, and 'c' is a <b>computable</b> value.
		Both a, b, and c are called <b>cells</b>. This is because they act like cells in Excel: some cells just have values, while
		the other cells are computed automatically according to their formulas.
		In this case, "a" and "b" have just static values, ad the value of "c" is a sum of "a" and "b". Hence "c" depends on values of "a" and "b".
	</div><div>	
		The value of "c" will <b>always</b> be the sum of "a" and "b", we don't need to update it manually.
		There is no proactive intrusion: you cannot change the value of "c" manually, it's changed based on the values of other cells(in this case "a" and "b").
		Here a, b and c are <span class="mn">data streams</span> as their values can change over time.
	</div><div>
		What's special about Firera is that it has completely declarative syntax.
		While other FRP libraries(Rx, Most) use method chains, the Firera app is described with a plain object(POJO: plain old JS object) and pure functions. It gives a lot of advantages that will be discussed later.
	</div><div>
		We instanciate a Firera app by passing this object to Firera function. Than we can change some input values(like "a" or "b") with <span class="mn">set(key, val)</span> method.
	</div><div class="nb">
		Note that you couldn't change "c", because it violates the main FRP priciple: a computable cell value should be computed only based on it's arguments, and never set manually.
	</div><div>
		In Firera language, "base" variable is called <b>plain base</b>, "a", "b", "c" are <b>cells</b>, 
		the expression [(n, m) => n + m, 'a', 'b'] is called <b>F-expression</b>, 
		and the function used in F-expression is called <b>formula</b>.
		Cells "a" and "b" relatively to cell "c" are called <b>arguments</b>.
		Cells which can be manually changed, like a or b, are called <b>free</b>
	</div><div>
		How Firera works is pretty easy to understand: when some of the observable cells changes, the values of arguments are being taken and passed to formula.
		The result of the formula invocation becomes the value of the cell.
		</div><div>
		This is what happens when we run "app.set('b', 32);":
		<ul>
			<li>
				Firera sets the values of cell "b" to 32
			</li>
			<li>
				Firera looks for the cells who depend on "b". In this case this is only one cell - "c"
			</li>
			<li>
				Firera wants to calculate the value of "c" according to the new value of "b":
				<ul>
					<li>
						Firera founds that we need values of "a" and "b" to compute the value of "c"
					</li>
					<li>
						Firera takes the values of "a"(10) and "b"(32) and passes it to the formula function of "c"
					</li>
					<li>
						As the formula of "c" is "(n, m) => n + m", and we pass "10" as the first argument and "32" as the second,
						we got ther result of "42"
					</li>
				</ul>
			</li>
			<li>
				Firera sets the current value of "c" to "42"
			</li>
		</ul>
		<div>
			One computable cell can depend on other computable cell also.
<code>
const base = {
	a: 10,
	b: 20,
	c: [(n, m) => n + m, 'a', 'b'],
<span class="add">	exp: 2,</span>
<span class="add">	d: [Math.pow, 'c', 'exp']</span>
}
// Create a Firera app instance
const app = Firera({
	__root: base
})
app.get('d'); // 900
</code>
		Here "d" depends both on "free" and "computable" cells(exp and c respectively).
		If you change the value of "a", Firera will compute the other cells in following order: c, d.
		
		</div>
		<div>
			A sef of cells, described with one plain base, is called <b>grid</b>. In our example we have only one grid which is called "__root".
			It can be visualized like this:<br>
			<img src="img/grid_1.png" alt=""/>
			The lines display dependencies between cells. Squares mean "free" cells, rounds are "computable".
		</div>
		<div>
			The grid could be as big as you need. E.g. something like this:
			<img src="img/grid_2.png" alt=""/>
			The idea of Firera is you can build the whole app as a big grid of computable cells.
		</div>
	</div><!--<ul class="pq">
		<li>
			<div class="q">Why do you call it "data stream"?</div>
			<div class="answer">
				Because
			</div>
		</li>
		<li>
			<div class="q">Why do you write "__root: ..."?</div>
			<div class="answer">
				Because
			</div>
		</li>
		
	</ul>-->
	</div>
	<div>
	<h2>Working with DOM</h2>
	<div>
		Let's move to more real-world examples.
		Say we need to validate adding a new comment to a comments' list. User enters his login, email and comment text and presses submit button.
		Let's start with validating login.
	</div>
	<div>
		At first glance, for getting a stream of what user inputs as a login, we could write something like this:
<code>
// function to validate login by length
var is_long = a => a.length > 2;

var base = {
	login: '',
	is_login_valid: [is_long, 'login'],
}
var app = Firera({
	__root: base,
});
// assigning handler that will change the "login" cell
document.querySelector('input[name=login]')
	.addEventListener('change', function(e){
		app.set('login', e.target.value);
	})
</code>	
	Each time user changes the value of input, we update of cell "login". And the value of cell "is_login_valid" will be true or false, depending on length of "login". 
	This will work as expected, but	it's a verbose and too imperative approach. We don't like to assign event handlers manually.
	</div><div>We can include special package to work with DOM, which is called HtmlCells instead. It allows us to create event streams of DOM events in a declarative manner.
	HtmlCells is one of default Firera packages which are included in Firera dist, so we should just 
	add it's name to <span class="mn">packages</span> parameter of our app's config.
	</div>
<code>
// function to validate login by length
var is_long = a => a.length > 2;

var base = {
	$real_el: document.getElementById('fr-app'),
	login: ['input[name=login]|getval'],
	is_login_valid: [is_long, 'login'],
}
var app = Firera({
	__root: base,
}, {
	packages: ['HtmlCells']
});
</code>
	<div>
		A mandatory thing for HtmlCells to work is to define a cell named "$real_el" which should contain the root DOM node of our app.
		Then we just mention the name of cell "'input[name=login]|getval" - and that's all! Firera automatically creates handler for the input.
		How it works step-by-step:
		<ul>
			<li>
				Firera founds the definition of "login" cell, which refers to the cell named "input[name=login]|getval"
			</li>
			<li>
				The cell "input[name=login]|getval" seems to be uninitialized(as there is no definition of it in our plain base), looks like Firera need to create an empty free cell, but...
			</li>
			<li>
				HtmlCells parses each cell name by regexp: <selector>|<aspect>. "input[name=login]|getval" matches this expression. <selector> is any valid CSS selector, and <aspect> appoints what
					exactly we want to listen from this DOM node(the full list os aspects see on the HtmlCells package page).
			</li>
			<li>
				HtmlCells package founds that we need to get values of DOM node by selector "input[name=login]". It assigns delegated event handler to $real_el, which listens 
				"change" and "keyup" events in all subtree.
			</li>
			<li>
				Each time user inputs something in input field, the DOM handler is fired and "input[name=login]" is updated with the value of input field.
			</li>
		</ul>
		
	</div>
	<div>
		There is two kinds of html cells: getters and setters. Getters listen for changes in DOM, e.g. events. Setters update the DOM with it's value.
		Let's add a class to form to indicate it's valid with a help of html setter.
<code>
var is_long = a => a.length > 2;

var base = {
	$real_el: document.getElementById('fr-app'),
	login: ['input[name=login]|getval'],
	is_login_valid: [is_long, 'login'],
	"form|hasClass(valid)": ['is_login_valid'],
}
var app = Firera({
	__root: base,
}, {
	packages: ['HtmlCells']
});
</code>
		"form|hasClass(valid)" is an example of setter. If the value of 'is_login_valid' cell is true, it will add class "valid" to nodes found with "form" selector in scope of "$real_el".
		It uses "hasClass" aspect, which requires one parameter: the name of class("valid").
	</div><div class="nb">
		Notice that if you write like this: <div class="subcode">login: 'input[name=login]|getval',</div>Firera will consider "login" as static cell with the value of string 'input[name=login]|getval'.
		We need to listen the other cell instead, that's why we write it in brackets. All the primitive, static values are written as is, and all the computable expressions are written in brackets.
	</div><div>
		Of course, we could write the same a bit simpler:
	</div>
<code class="js">
{
	$real_el: document.getElementById('fr-app'),
	"form|hasClass(valid)": [is_long, 'input[name=login]|getval'],
}
</code>
		<div>
			...but we require the field <span class="mn">is_login_valid</span> to be present to help us later.
		</div>
		<div>
			We write a small example that shows how to work with DOM without pain of assigning handlers etc.
			Our app is almost completely declarative. The only proactive intrusion is using html setter "hasClass", which changes the property of DOM node.
			We can escape from this later by using cool Ozenfant templates.
		</div>
		<ul class="pq">
			<li>
				<div class="q">Will it work without $real_el defined?</div>
				<div class="answer">
					No
				</div>
			</li>
		</ul>
	</div>
	<div>
		<h2>"Total FRP" concept</h2>
		<div>
			If you look closer to previous example, you can see that every values that depend on event is also an event stream!
			'input[name=login]|getval' is an original event stream of values of input node in DOM. 'login' field is also an event stream with equvivalent values, and 'is_login_valid' is an event stream too!(with Boolean values).
		</div><div>This table how the values of these cells change as user enters something into input:</div><div>
			<table class="tbl">
			<tr><td>"input[name=login]" DOM node value        </td><td>"input[name=login]" cell </td><td> "is_login_valid" cell </td></tr>
			<tr><td> M     </td><td> M </td><td> false </td></tr>
			<tr><td> My      </td><td>  My  </td><td>   false </td></tr>
			<tr><td> Myk </td><td> Myk   </td><td>    true </td></tr>
			<tr><td> Myko </td><td> Myko    </td><td>    true </td></tr>
			<tr><td> Mykol </td><td> Mykol    </td><td>    true </td></tr>
			<tr><td> Mykola </td><td> Mykola   </td><td>    true </td></tr>
			</table>
		</div>
		<div>
			This is an example how one stream depends on other with formula. I call this "Total FRP" concept, which means that all values in application should be event streams which depend on each other.
		</div>
	</div>
	<div>
		<h2>Managing streams</h2>
		<div>
			We need to validate also user's email(with RegExp). If the form is valid, and user clicks "Send" button, we should do some useful work, e.g. and AJAX request.
		</div>
<code>
const simple_email_regex = /\S+@\S+\.\S+/;
const is_email_valid = (str) => {
	return simple_email_regex.test(str);
}
const is_long = a => a.length > 2;

const base = {
	$real_el: document.getElementById('fr-app'),
	
	login: ['input[name=login]|getval'],
	email: ['input[type=email]|getval'],
	
	is_login_valid: [is_long, 'login'],
	is_email_valid: [is_email_valid, 'email'],
	is_form_valid: ['&&', 'is_email_valid', 'is_login_valid'],
	"form|hasClass(valid)": ['is_form_valid'],
	
	send_form: ['&&', '-is_form_valid', 'button.send|click'],
	add_comment_request: ['transistAll', (email, name, text) => {
		// ... some ajax request here...
		console.log('It works!', email, name, text);
	}, 'send_form', '-email', '-login', '-textarea[name=text]|getval'],
}
const app = Firera({
	__root: base,
}, {
	packages: ['htmlCells']
});
</code>
		<div>
		The form is valid when both login and email are valid.
		We implement this by using '&&'. It's a built-in Firera function that works like '&&' operator in JS, but on data streams instead of simple values.
		The equivalent is to write:
		</div>
<code>
	is_form_valid: [(a, b) => {
		return Boolean(a && b);
	}, 'is_email_valid', 'is_login_valid'],
</code>
		<div>
			Each time the values of 'is_email_valid' or 'is_login_valid' changes, the function is run passing both arguments.
			The '&&' built-it function is just a kind of 'syntactic sugar' that shortens your code.
		</div>
		<div>
			Now we should understand, when are form is ready to be sent. It happens when:<br>
			a) user clicks "Send" button<br>
			b) The value of cell "is_form_valid" is truthy.<br>
		</div>
		<div>
			The naive approach will look like this:
<code>
	send_form: ['&&', 'is_form_valid', 'button.send|click'],
</code>
			but this will not work.
			Imagine the following scenario:
			<ul>
				<li>
					User inputs something in text fields, but leaves email empty, and clicks "Send"
				</li>
				<li>
					The value of "is_form_valid" will be "false", the value of "button.send|click" is an Event object. It's truthy, but the result will be false. Everything is right so far.
				</li>
				<li>
					User enters valid email. The value of "is_form_valid" becomes "true".
				</li>
				<li>
					As the value of "is_form_valid" changes, Firera calculates the "send_from" cell. true && Event => true! So the form is being sent immediately when email becomes valid... FAIL!
				</li>
			</ul>
			Hence we understand, that we should run the "send_form" function only when "Send" button is clicked, and do nothing when the value of "is_form_valid" changes.
			In Firera it's called "passive listening". One cell depends on the other, but the change in parent cell doesn't invoke recalculation of child.
			The syntax for this is simple - add a minus "-" before the name of argument in F-expression.
<code>
	send_form: ['&&', '-is_form_valid', 'button.send|click'],
</code>
			This small changes makes our app work correct!
			<div class="nb">
				Note that this can be used only when you have at least one active argument.
<code>
	foo: ['-bar'],
</code>
				or
<code>
	foo: ['-bar', '-baz'],
</code>
				are pointless as "foo" will be never computed!
			</div>
		</div>
		<div>
			Cell types
			
		</div>
	</div>
	</div>
			<script>
					$(document).ready(function() {
							$('code').each(function(i, block) {
									hljs.highlightBlock(block);
							});
					});
					
					$('.q').click(function(){
						$(this).parent().find('.answer').toggle();
					})
			</script>
		</body>
</html>
