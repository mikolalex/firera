<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
		<head>
				<title>Firera - intro</title>
				<meta charset="UTF-8">
				<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<link rel="stylesheet" href="guide.css" />
				<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css">
				<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
				<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
		</head>
		<body>
				<div id="content">
				<div>
				<h1>Firera</h1>
				<h2>Базові принципи Firera - приклад із коментарем</h2>

Для початку Firera.js можна представити як FRP-бібліотеку, поруч з такими проектами, як Rx.js, cellx, modx, Bacon і т.п. В ній є т.зв. потоки івентів(event-streams), обчислювані комірки і багато інших стандартних атрибутів FRP. Однак Ф. практикує кардинально інший, декларативний, підхід для опису взаємозалежності між потоками даних. Внаслідок цього, бібілотека має кращу читабельність, широкі можливості для застосування ФП, кращу структурованість коду,і ще багато всяких переваг, але подивіться спочатку на код, і вам стане ясно.

Розглянемо простий приклад - форму додавання нового коментаря.
<code class="js">
var $root = $('#enter-name-and-email-form');
var simple_email_regex = /\S+@\S+\.\S+/;
var test_regex = (reg) => {
    return (str) => {
        return reg.test(str);
    }
}
var is_email_valid = test_regex(simple_email_regex);
var app = {
    $el: $root,
    email_valid: [is_email_valid, 'input.email|getval'],
    text_entered: [(a) => { return a.length > 2 }, 'textarea.text|getval'],
    form_valid: ['&&', 'email_valid', 'text_entered'],
    send_form: ['transist', '-form_valid', 'button.send|click'],
    do_something: ['transistAll', (email, name) => {
        // do something useful with entered data, e.g. AJAX request
    }, 'send_form', '-input.email|getval', '-textarea.text|getval'],
};
Firera({
    __root: app
})
</code>
Розібравши цей приклад, ви зрозумієте 80% бібліотеки(а на розбір інших 20% доведеться витратити ще 80% часу, так-так...).
Основна одиниця Ф. - це грід, тобто, згрупований набір взаємопов"язаних комірок(потоків даних). Як бачите, грід являє собою простий об"єкт(POJO), передавши який в глобальну функцію Firera, ми створимо інстанс нашого застосунку. Такий підхід має багато переваг, наприклад, ми можемо легко організувати "наслідування" і "домішки" між різними грідами за допомогою простих методів накшталт Object.assign, але про це потім.
Отже, які типи комірок є в Ф. і як вони оголошуються?
<code>
    $el: $root,
</code>
Це - найпростіший тип - комірка із статичним значенням. Правило дуже просте: усе, що ви запишете в правій частині гріда, буде інтерпретовано як буквальне значення, окрім масиву.
<code>
{
    sense: 42, // все ок, це буде просто число 42
    name: 'Carl', // просто строчка
    fib: [0, 1, 1, 2, 3, 5, 8], // ПОМИЛКА! 
    fib: ['just', [0, 1, 1, 2, 3, 5, 8]], // ось так пишуться масиви, якщо ви не хочете, щоб фреймворк їх сприйняв за свої конструкції
    name: ['just', 'Carl'], // так теж можна. Більш багатослівно, але підходить для випадку, коли ви не впевнені в типі змінної
}
</code>
Йдемо далі!
<code>
    email_valid: [is_email_valid, 'input.email|getval'],
</code>
Ось в цьому - вся суть бібліотеки. email_valid є коміркою, яка обраховується на основі значення іншої комірки('input.email|getval'). Записавши 'input.email|getval', ми уже створюємо комірку, потік даних якої означає той текст, який буде вводитись в input. Це один із прикладів вищезгаданого "декларативного підходу". Тут '.input.email' - це селектор(при чому, він може бути як завгодно складним, з пробілами і т.п.), а 'getval' - т.зв. "аспект", який вказує, яка саме характеристика ДОМ-вузла буде використана для створення потоку даних.
is_email_valid - функція, яка буде перевіряти передану їй строчку на відповідність регулярному виразу.
Значення комірки email_valid буде обраховуватись як результат застосування функції is_email_valid до значення комірки 'input.email|getval'. В Ф. застосовується префіксна нотація(знайома по таким мовам, як, наприклад, Lisp): спочатку йде функція, далі її аргументи. Таким чином, ви можете застосовувати чисті функції для опису взаємозв"язку між комірками.
І тут ми підходимо до головного, принципового моменту, який лежить в основі усієї філософії Ф.
**Значення, які залежні від потоків даних є також потоками даних!**
В більшості туторіалів по ФРП наводиться його використання для абстрагування речей, які інтуїтивно виглядають як потоки даних: наприклад, введена юзером інформація, кліки тощо. Однак, наприклад, стан форми - валідна вона чи ні - не виглядає як потік даних з першого погляду, чи не так? Але оскільки він залежний від потоків даних, він також є потоком даних. Розглянемо на таблиці, що показує значення різних комірок по мірі того, як юзер вводить дані в форму.

<table class="tbl">
<tr><td> Поле input.email        </td><td> Комірка "input.email|getval" </td><td> Комірка "is_email_valid"  </td></tr>
<tr><td> m     </td><td> m </td><td> false </td></tr>
<tr><td> me      </td><td>  me  </td><td>   false </td></tr>
<tr><td> me@ </td><td> me@    </td><td>    false </td></tr>
<tr><td> me@e </td><td> me@e    </td><td>    false </td></tr>
<tr><td> me@ex </td><td> me@ex    </td><td>    false </td></tr>
<tr><td> me@ex. </td><td> me@ex.    </td><td>    false </td></tr>
<tr><td> me@ex.c </td><td> me@ex.c    </td><td>    true </td></tr>
<tr><td> me@ex.co </td><td> me@ex.co    </td><td>    true </td></tr>
<tr><td> me@ex.com </td><td> me@ex.com    </td><td>    true </td></tr>
</table>

Як бачите, "is_email_valid" є теж потоком даних, однак в процесі вводу мейла його значення зміниться лише один раз - тоді, коли імейл стане валідним. Те саме і з наступною коміркою:
<code>
    text_entered: [(a) => { return a.length > 2 }, 'textarea.text|getval'],
</code>
Ми використовуємо чисту функцію, результат виконання якої зі значенням комірки 'textarea.text|getval' буде означати, чи ввів юзер якісь дані в поле name.
Як ви помічаєте, Ф. схиляє вас до широкого застосування чистих функцій, що дає можливість використовувати весь арсенал методології ФП. Наприклад, фанатичні прихильники ФП могли б написати замість функції
<code>
(a) => { return a.length > 2 }
</code>
наступний код:
<code>
var prop = (a) => {
	return (b) => {
		return b[a];
	}
}
var gt = (a) => {
	return (b) => {
		return b > a;
	}
}
var len_gt_2 = _.flow(prop(length), gt(2));
</code>
Як бачите, тут і карінг, і композиція функцій, усі смачненькі штучки)
Комірка text_entered буде приймати булеві значення в залежності від того, що ввів юзер.
<code>
    form_valid: ['&&', 'email_valid', 'text_entered'],
</code>
Вся форма буде валідною тоді, коли будуть валідні дані в полях email та name.
Отже, ми створюємо ще одну комірку, яка буде означати валідність усієї форми, станеться це тільки тоді, коли обидві інші комірки матимуть значення true. '&&' - функція із стандартної бібліотеки F. Однак не лякайтесь, вам не доведеться вчити багато нового, в даному випадку еквівалентним записом було б:
<code>
    form_valid: [(a, b) => a && b, 'email_valid', 'text_entered'],
</code>
Далі нам потрібно визначити подію, коли форма буде готова до відправки. Це станеться тоді, коли юзер клікнув по кнопці "Відправити" і форма в цей момент була валідною. Для відображення цього взаємозв"язку використаємо функцію transist з стандартної бібліотеки: вона повертає свій другий аргумент, якщо перший = true, і false у іншому випадку.
<code>
    send_form: ['transist', '-form_valid', 'button.send|click'],
</code>
Однак виникає питання, навіщо перед form_valid стоїь знак мінус? Щоб зрозуміти це, потрібно поглянути на принципи FRP.
Нехай у нас є приклад:
<code>
var app = Firera({__root: {
    a: 30,
    b: 12,
    c: [(a, b) => a + b, 'a', 'b']
}})
// перевіримо значення "с"
app.get('c'); // 42

app.set('b', 10);
app.get('c'); // 40

app.set('a', 1);
app.get('c'); // 11
</code>
(ви вже помітили, наскільки фірера-код читабельніший за своїх імперативних аналогів, якщо зрозуміти його принцип?)
Це базовий приклад, з якого починають вивчати суть frp. Головний момент тут в тому, що зміна в кожній із комірок-аргументів(a, b) буде викликати перерахунок значення c. Однак така поведінка не завжди потрібна.
У нашому прикладі, подія send_form має статись тільки тоді, коли відбувається зміна в комірці 'button.send|click', тобто, коли юзер, фактично, клікає по кнопці. Якщо ж зміна відбудеться в комірці 'form_valid', ми не повинні нічого робити, т.як само по собі те, що форма стала валідною - не привід для її відправки ;) Для таких ситуацій в Ф. є механізм "пасивного слухання": значення змінної буде обраховуватись, однак зміни в цьому значенні не призведуть до перерахування в залежних комірках. В синтаксисі пасивне слухання позначається мінусом перед іменем комірки-аргумента.
Застосовувати його треба тільки тоді, коли ви знаєте, навіщо це робите. Наприклад, такий код буде працювати погано:
<code>
var app = Firera({__root: {
    a: 30,
    b: 12,
    c: [(a, b) => a + b, '-a', 'b']
}})
// перевіримо значення "с"
app.get('c'); // 42

app.set('b', 10);
app.get('c'); // 40

app.set('a', 1);
app.get('c'); // 40! значення не змінилось, т.як ми слухали "а" пасивно, і його зміна не спричинила перерахунку результату!
</code>
Остання строчка може робити корисну роботу при відправці форми:
<code>
    do_something: ['transistAll', (email, name) => {
        // do something useful with entered data, e.g. make an AJAX request
    }, 'send_form', 'input.email|getval', 'textarea.text|getval'],
</code>
Принцип роботи transistAll дещо інший: результатом є застосування функції до значень аргументів, починаючи з другого, якщо перший аргумент = true. Аби не робити зайвих перевірок, ми будемо слухати активно тільки зміни в потоці 'send_form', слухаючи інші потоки пасивно.

Ф., в певному розумінні, перевертає в вашому застосунку усе з ніг на голову. Зазвичай ми мислимо так "від причини - наслідок". Наприклад, "юзер клікнув по кнопці, отже, ми повинні зробити А, Б, і Ц". З Ф. вам доведеться мислити навпаки: "Є подія А. За яких умов вона настає? Вона настає за умов Б, Ц, і Д".

Другий момент - інкоил набагато простіше мислити станами, аніж змінами. Наприклад, нам потрібно додати показ ерор меседжа, якщо юзер ввів некоректний мейл. Припустимо, що у нас в хтмлі є блок .error-msg.email, який містить в собі це повідомлення, однак він прихований. Наша задача - показати його, якщо буде введений невалідний мейл і приховати, коли він стане валідним.
<code>
var app = {
    $el: $root,
    email_valid: [is_email_valid, 'input.email|getval'],
    text_entered: [(a) => { return a.length > 2 }, 'textarea.text|getval'],
    form_valid: ['&&', 'email_valid', 'text_entered'],
    send_form: ['transist', '-form_valid', 'button.send|click'],
    '.error-msg.email|display': ['!', 'email_valid'],
    do_something: ['transistAll', (email, name) => {
        // do something useful with entered data, e.g. AJAX request
    }, 'send_form', '-input.email|getval', '-textarea.text|getval'],
};
</code>
Божествена простота! В імперативному царстві такий взаємозв"язок ми б описали приблизно так: "якщо імейл змінюється, і стає невалідним, то показати ерор меседж. Якщо ж він стає валідним, а перед цим був невалідним, то приховати ерор меседж". Як бачите, у декларативному царстві це все робиться набагато легше, простіше і ясніше. 
Вбудована функція Ф. "!" означає, як ви можете здогадатись, заперечення і еквівалентна (a) => !a;
Однак, ми упустили один момент: ерор меседж треба показувати не раніше, аніж юзер закінчить введення. Тобто, вже після того, як відбудеться хоча б одна подія blur. Тож змінимо наш код, використовуючи вже відому функцію transist:
<code>
    '.error-msg.email|display': ['transist', '.error-msg.email|blur', ['!', 'email_valid']],
</code>
Тут ви бачите ще одну особливість синтаксису - вкладені Ф-вирази.(Ф-виразом називаємо ось ці масиви, які слугують для опису залежності чарунки). Замість того, щоб створювати окрему комірку, яка б описувалась виразом ['!', 'email_valid'], ми можемо просто вставити цей вираз в потрібному місці.
Поки юзер не зробить жодної blur-події, значення комірки '.error-msg.email|blur' буде дорівнювати undefined, таким чином, відображення не буде змінюватись. Після першого ж blur івенту значенням комірки '.error-msg.email|blur' стане сам об"єкт цього івенту, це буде truthy-значення, отже, транзистор спрацює :)


				</div><div>
			<h2>
				Короткий термінологічний словник
			</h2>
				Для зручності і уникнення плутатини, говорячи про Фіреру ми будемо називати певні речі усталеними назвами, така собі внутрішня термінологія.
				Розберемо на прикладі:
<code>
var minus = (v) => {
	return v * (-1);
}
var app_base = {
	'a': 10,
	'b': 20,
	'foo': [
		(n, m) => {
			return Number(n) + Number(m);
		}, 
		'a', 
		[minus, 'b']
	]
	...
}
var app = Firera({
	__root: app_base
})
</code>
				<ul>
						<li>
<pre>{
	'a': 10,
	'b': 20,
	'foo': [
		(n, m) => {
			return Number(n) + Number(m);
		}, 
		'a', 
		[minus, 'b']
	]
	...
	}</pre> - ось це все називається <b>проста основа</b>. Це простий JS об"єкт, який описує структуру комірок, їх взаємов"язок. При інстанціації застосунку з простих основ устворюються <b>гріди</b>(решітки) - основні одиниці Фірери.
						</li>
						<li>
								app - це <b>Фірера-застосунок</b>. Може містити в собі один або кілька грідів. Обов"язково має бути один кореневий грід. Кожен грід - це сукупність пов"язаних між собою <b>комірок</b>.
						</li>
						<li>
								'a', 'b', 'foo',  - це <b>комірки</b>(англ. <b>cell</b>). Кожна комірка може мати або статичне значення(як комірки "a" та "b"), або динамічне значення, яке обраховується на основі <b>F-виразу</b>.
						</li>
						<li>
<pre>[
	(n, m) => {
		return Number(n) + Number(m);
	}, 
	'a', 
	[minus, 'b']
]</pre> - оця вся конструкція називається <b>F-вираз</b>.(по аналогії з S-виразами в ліспі). 
								F-вираз може містити вкладені F-вирази, в даному випадку [minus, 'b'].
								F-вираз зазвичай складається із типу чарунки(опціональний елемент), формули і аргументів.
						</li>
						<li>
								(n, m) => {	return Number(n) + Number(m); } - це <b>формула</b>. Формулою називаємо будь-яку функцію, яка слугує для обрахування значення комірки. Вона може бути вписана на місці у вигляді літералу, а може бути і взяти із пакету і записана строчкою.
						</li>
						<li>
								'a', [minus, 'b'] - це <b>аргументи</b> F-виразу. Аргументи - це ті комірки, значення яких буде підставлятись у формулу при обрахунку значення нашої комірки.
						</li>
					
				</ul>
				
				
				</div><div>
			<h2>
				Типи комірок
			</h2>
			Існує кілька різних способів обрахування значення комірки на основі її "батьків" - комірок-аргументів.
			Найпростіший, базовий спосіб - це т.зв. формула.
			<code>
			var app = Firera({__root: {
				a: 30,
				b: 12,
				c: [(a, b) => a + b, 'a', 'b']
			}})
			app.get('c'); // 42
			app.set('b', 100);
			app.get('c'); // 130
			</code>
			Принцип роботи наступний: як тільки змінюється один із аргументів(в нашому випадку - а чи b), ми заново обраховуємо значення комірки із новими 
			значеннями аргументів. Для цього ми передаємо значення аргументів в функцію(в ідеалі, чисту), яка повертає результат. Це і стає значенням нашої комірки.
			Однак такий принцип роботи підходить не для усіх випадків. Припустимо, ми хочемо написати комірку, яка б слухала зміни в кількох інших комірках
			і логувала їх. Приблизно так:
			<code>
			var app = Firera({__root: {
				a: 30,
				b: 12,
				c: [(a, b) => {
					console.log('Some cell changed!', a, b);
				}, 'a', 'b']
			}})
			app.set('b', 100);
			// Some cell changed 30, 100
			app.set('a', 22);
			// Some cell changed 22, 100
			app.set('a', 22); // same value
			// Some cell changed 22, 100
			</code>
			Як бачимо, тип комірки "формула" тут не дасть очікуваного результату: при кожній зміні комірки-батька ми будемо заново отримувати значення усіх батьківських комірок.
			Тож буде не ясно, яка з них змінилась, зрештою. Для таких випадків є тип чарунок - "лійка", або ж funnel.
			Погляньмо:
			<code>
			var app = Firera({__root: {
				a: 30,
				b: 12,
				c: ['funnel', (cell_name, cell_value) => {
					console.log('Cell', cell_name, 'changed to', cell_value);
				}, 'a', 'b']
			}})
			app.set('b', 100);
			// Cell b changed to 100
			app.set('a', 22);
			// Cell a changed to 22
			app.set('a', 22); // same value
			// Cell a changed to 22
			</code>
			Тип комірок пишеться першим у F-виразі, тільки для дефолтного типу "формула" він може опускатись.
			Як бачите, слухаючи батьківські комірки способом funnel, при кожній зміні батьківської комірки ми отримуємо її ім"я і значення.
			Це широко застосовується, наприклад, при роботі з DOM-подіями. Наприклад, якщо нам потрібно "об"єднати" два "потоки".
			<code>
			var second = (_, a) => a;
			var app = Firera({__root: {
				'click_on_form_or_div_or_button': ['funnel', second, 'form|click', 'div|click', 'button|click'],
			}})
			</code>
			Тут подія click_on_form_or_div_or_button буде об"єднанням трьох подій.(звісно, це можна було записати простіше, за допомогою складного CSS-селектора, але тут ми просто хочемо продемогнструвати принцип)
			
			Однак, що якщо ми захочемо записувати зміни в якийсь "журнал"? Так щоб результатом комірки "c" був список усіх змін її батьківських комірок, які відбувалися раніше.
			Нам хочеться щоб було так:
			<code>
			var app = Firera({__root: {
				a: 30,
				b: 12,
				c: ['funnel', (cell, val) => {
					// SOME MAGIC!
				}, 'a', 'b']
			}})
			app.set('b', 100);
			app.get('c'); // [['b', 100]]
			app.set('a', 22);
			app.get('c'); // [['b', 100], ['a', 22]]
			app.set('a', 22);
			app.get('c'); // [['b', 100], ['a', 22], ['a', 22]]
			</code>
			... і так далі. Зрозуміло, що потрібен якийсь спосіб зберігання попередніх даних.
			Звертатись до сторонніх глобальних змінних всередині функцій-формул Firer'и - тяжкий гріх!
			Т.як таким чином ми робимо наш код брудним та крихким, втрачаючи усі переваги, за які бореться Firera.
			Виходом із цієї ситуації є ще один тип чарунок, який називається closure.
			В цьому типі функція-формула спочатку запускається, і перший її запуск повинен повернути нову функцію, яка буде використовуватись як формула.
			Простіше це побачити по коду:
			<code>
			var app = Firera({__root: {
				a: 30,
				b: 12,
				c: ['closureFunnel', () => {
					var log = [];
					return (cell, val) => {
						log.push([cell, val]);
						return log;
					}
				}, 'a', 'b']
			}})
			app.set('b', 100);
			app.get('c'); // [['b', 100]]
			app.set('a', 22);
			app.get('c'); // [['b', 100], ['a', 22]]
			app.set('a', 22);
			app.get('c'); // [['b', 100], ['a', 22], ['a', 22]]
			</code>
			По-перше, ми бачимо, що, в той час як типи funnel і formula(дефолтний) є взаємовиключними, тип closure можна вільно комбінувати з будь-яких з цих типів.
			Ще раз поясню принцип роботи цього типу: при першому запуску ваша функція-формула повинна повернути НОВУ функцію, яка вже і буде використовуватись в якості формули для обрахунку.
			При цьому можна створити якісь корисні змінні в локальній області видимості, які будуть доступні новоствореній функції, власне, для цього і потрбен цей тип.
			Він дозволяє реалізовувати багато корисних задач, не дозволяючи, при цьому, забруднити ваш застосунок глобальними змінними із shared mutable state.
			
			Наступний тип комірок, який буде незамінним  - це тип async. Тут усе просто - він використовується в тих випадках, коли функція-формула є по своїй суті асинхронною,
			тобто, повертає потрібний результат не одразу, а за якийсь час) Для цього в типі async першим аргументом завжди є функція-колбек, за допомогою якої можна "повернути" результат виконання.
			Приклад:
			<code>
			var app = Firera({__root: {
				'user': 'Mikolalex',
				'posts: ['async', (returner, username) => {
					$.get('/posts/' + username, function(data) {
						console.log('data received!');
						returner(data);
					})
				}, 'user']
			}})
			</code>
			Тут я спеціально називаю перший параметр словом returner, щоб підкреслити його аналогію із оператором return, т.як вони виконують ту саму задачу.
			Якщо ж така аналогія видається вам такою, що збиває з толку, ви можете використовувати інші назви, наприклад, прийняту в спільноті Node.js назву cb.
			<code>
			var app = Firera({__root: {
				'time': 3,
				'await': ['async', (cb, time) => {
					setTimeout(() => {
						cb(time);
					}, time * 1000);
				}, 'time'],
				'foo': [(t) => {
					console.log(t, 'seconds passed!');
				}, 'await']
			}})
			</code>
			Таким чином, Фірера дозволяє використовувати асинхронні функції поруч з синхронними практично без додаткових зусиль.
			
			І останнім важливим типом комірок в Ф. є тип nested. Як ви помітили, в будь-яких комірках, за будь-яких умов результат обчислення функції-формули
			завжди "кладеться" в одну комірку. Звичайно, в імперативному програмуванні ми звикли до іншого: брудна функція може не тільки повертати якесь значення, але і змінювати кілька інших видимих для неї формул.
			Ця, в цілому шкідлива, поведінка може бути інколи корисною. У Фірері для цього є окремий тип - nested, який дозволяє реалізувати подібний підхід, при цьому дотримуючись політики SDP(single definition point).
			Ми можемо за результатами обчислення класти значення в те чи інше, наперед обумовлене місце - таку собі "підкомірку"
			<code>
			var get_sum = () => {
				var sum = 0;
				return (num) => {
					sum += num;
					return sum;
				}
			}
			var app = Firera({
				__root: {
					num: 1,
					nums: ['nested', function(cb, a){
							if(a % 2){
								cb('odd', a);
							} else {
								cb('even', a);
							}
					}, ['odd', 'even'], 'num'],
					odd_sum: ['closure', get_sum, 'nums.odd'],
					even_sum: ['closure', get_sum, 'nums.odd'],
				}
			});
			app.set('num', 2);
			// odd_sum: undefined, even_sum: 2
			app.set('num', 3);
			// odd_sum: 3, even_sum: 2
			app.set('num', 4);
			// odd_sum: 3, even_sum: 6
			</code>
			В цьому типі комірок в функцію-формулу, як і в типі async, передається функція-колбек, за допомогою якої ми повертаємо результат.
			Але, на відміну від типу async, ми не просто повертаємо результат, а і вказуємо, в яку саме "підкомірку" його покласти!
			Список підкомірок наперед відомий, і він перераховується після функції-формули(в даному випадку, дві підкомірки - odd та even).
			Ці підкомірки ззовні є звичайними комірками, на них можна посилатись, використовуючи синтаксис назва батьківської комірки nested + '.' + назва підкомірки.
			Також, як ви помітили, ніщо не заважає повертати значення комірок асинхронно, тому тип nested, таким чином, уже включає в себе можливості типу async.
			Тип nested є способом розщеплення потоків. У нашому прикладі, він ділить потік чисел на два потоки - потік парних і непарних чисел. Таким чином, він є доповнюючою протилежністю типу funnel, який може об"єднувати кілька потоків в один.
			
			</div>
			<div>
					<h2>
							Вкладені гріди
					</h2>
					<h3>
							Статичні вкладені гріди
					</h3>
					Дотепер ми розбирали приклади, коли весь застосунок(Firera.app) складався із одного-єдиного гріда.
					Однак, цього буде достатньо лише для найпростіших випадків. Firera є в першу чергу бібліотекою для GUI. DOM має деревовидну структуру, і працюючи з ним буде зручно, щоб наші гріди теж були вкладені один в оден.
					Для цього існує простий механізм, базований на внутрішніх ковенціях: значення усіх комірок, ім"я яких починається з $child_, буде трактуватись як вкладений грід.
<code>
var app = Firera({__root: {
	foo: 10,
	$child_crane: {
		width: 40,
		height: 120,
		weight: [(w, h) => {
			return (w+h)/10;
		}, 'width', 'height'],
	},
	heron: {
		b: 10,
		c: 40,
	},
}});


console.log(app.get('weight', '/crane')); // 16
</code>
			Ми бачемо дві чарунки, оголошені із статичними значеннями: $child_crane і heron.
			Однак оскільки назва комірки $child_crane підходить під наш шаблон, буде автоматично створено новий вкладений грід із значенням чарунки $child_crane в якості простої основи!
			Цей грід під назвою crane буде вкладеним в кореневий грід. Щоб впевнитись в цьому, отримаємо якесь значення із гріда crane. Для цього, окрім назви чарунки, ми передамо в метод .get()
			також і шлях до неї, який в даному випадку буде простим - /crane.
			Щоб краще зрозуміти, як працює система шляхів і вкладеності, зробимо ще один рівень вкладеності.
<code>
var app = Firera({__root: {
	foo: 10,
	$child_crane: {
		width: 40,
		height: 120,
		weight: [(w, h) => {
			return (w+h)/10;
		}, 'width', 'height'],
		$child_1: {
			name: 'Busol',
			gender: 'male',
		},
		$child_2: {
			name: 'Buska',
			gender: 'female',
		},
	},
	heron: {
		b: 10,
		c: 40,
	},
}});
console.log(app.get('name', '/crane/1')); // 'Busol'
console.log(app.get('name', '/crane/2')); // 'Buska'
</code>
		Отже, ви можете використовувати довільні імені для ваших вкладених грідів, навіть такі, що містять тільки цифри.
		<h3>
			Лінкінг комірок між грідами	
		</h3>
		Однак ізольовані гріди, навіть вкладені один в оден, мало що нам дадуть. Потрібен механізм зв"язку, щоб дані могли циркулювати між ними.
		<code>
var app = Firera({__root: {
	multiplier: 10,
	first_crane_weight: ['crane_1/weight'],
	$child_crane_1: {
		width: 40,
		height: 120,
		weight: [(w, h, m) => {
			return (w+h)/m;
		}, 'width', 'height', '../multiplier']
	},
	$child_crane_2: {
		width: 50,
		height: 80,
		weight: [(w, h, m) => {
			return (w+h)/m;
		}, 'width', 'height', '/multiplier']
	},
}});
console.log(app.get('weight', '/crane_1')); // 16
console.log(app.get('first_crane_weight')); // 16
console.log(app.get('weight', '/crane_2')); // 13
</code>
		Тут представлено кілька способів лінкінга комірок між різними грідами.
		Наприклад, комірка '../multiplier' звертається до батьківського гріда. Така адресація схожа на ту, що застосовується у файловій системі, але вона має деякі відмінності і обмеження!(про це нижче)
		А тут ми звртаємось до комірки вкладеного гріда:
<code>
	first_crane_weight: ['crane_1/weight'],
</code>
		Питання - чому ми написали ['crane_1/weight'], а не просто 'crane_1/weight'? Тому що все, окрім масиву, буде розцінено як статичне значення. Тобто, якби ми написали 
<code>
	first_crane_weight: 'crane_1/weight',
</code>
		то значенням комірки first_crane_weight була би СТРОЧКА 'crane_1/weight'. В нашому випадку, ми хочемо, щоб значення бралось із іншої комірки.
		В другому вкладеному гріді ми використовуємо адресацію "від кореня": '/multiplier'. Слеш на початку означає відлік від кореневого гріда.
		Окрім цього, існує синтаксис для лінкінга комірок з усіх вкладених або усіх батьківських грідів.
		<code>
'any_click_in_children': ['*/some_click'], // слухаємо значенням комірок some_click 
					// із усіх вкладених грідів-безпосередніх дітей
'any_click_inside': ['**/some_click'], // слухаємо значенням комірок some_click 
					// із усіх вкладених грідів якої завгодно глибини
'any_click_upper': ['^^/some_click'], // слухаємо значенням комірок some_click 
					// із усього ланцюжка батьківських грідів
		</code>
		Однак, для того щоб ви, використовуючи лінкінг комірок, не приготували смачне спагетті, існує обмеження - <b>не більше одного слеша в адресі</b>.
		Тобто, не можна писати ось так: ../../a, ../foo/b і т.п. Якщо вам дуже хочеться це зробити, подумайте, а чи все добре із структурою вашого застосунку?..
		</div>
		<div>
		<h2>
				Списки
		</h2>
				<h3>
						Списки на основі статичних даних
				</h3>
		Як ви, мабуть, помітили, наш попередній приклад із двома журавлями дещо порушує принцип DRY - там повторюється багато коду.
		Перший і другий вкладені гріди відрізняються тільки статичними даними, структура ж їх динамічних комірок однакова.
		Ми можемо трохи спростити цей вираз:
<code>
var crane = {
		weight: [(w, h, m) => {
			return (w+h)/m;
		}, 'width', 'height', '../multiplier']
}
var cranes = [
	{
		width: 40,
		height: 120,
	},
	{
		width: 50,
		height: 80,
	},
]
var app = Firera({__root: {
	multiplier: 10,
	first_crane_weight: ['crane_1/weight'],
	$child_crane_1: Object.assign({}, cranes[0], crane),
	$child_crane_1: Object.assign({}, cranes[1], crane),
}});
</code>
		Уже вимальовується розрінення двох складових: структури і даних.
		Структура для обох грідів однакова, а дані різняться.
		Припустимо, нам хочеться створити наперед невідому кількість вкладених грідів типу crane, в залежності від масиву вхідних даних.
		Для цього існує конструкція "список".
<code>
var cranes = [
	{
		width: 40,
		height: 120,
	},
	{
		width: 50,
		height: 80,
	},
	{
		width: 70,
		height: 160,
	},
]
var app = Firera({
	__root: {
		multiplier: 10,
		$child_cranes: ['list', {
			type: 'crane',
			data: cranes, 
		}]
	},
	crane: {
		weight: [(w, h, m) => {
			return (w+h)/m;
		}, 'width', 'height', '^^/multiplier']
	}
});

console.log(app.get('weight', '/cranes/0'); // 16
console.log(app.get('height', '/cranes/0'); // 120

console.log(app.get('weight', '/cranes/1'); // 13
console.log(app.get('height', '/cranes/1'); // 80

console.log(app.get('weight', '/cranes/2'); // 23
console.log(app.get('height', '/cranes/2'); // 160

</code>
				Вся "сіль" тут в конструкції ['list', { ... }]
				Для початку, що ж таке list? Це, вочевидь, не тип комірки. І не функція, так як після її імені не йдуть списки комірок-аргументів.
				List - це макрос(знову ж таки, можна провести аналогію з макросами ліспа). Зараз ми не будемо детально розглядати, як саме працюють макроси в Фірері, лише звернемо увагу
				на інтерфейс макроса list. Його задача - будувати набір однотипних вкладених грідів з різними даними. В нашому прикладі тип гріда - це crane, і він описаний в початковій структурі поруч із іншим типом, __root.
				На кожен елемент в масиві data буде створений вкладений грід типу crane, при цьому значення комірок width і height будуть підставлені в нього з відповідного елемента масива.
				<br><br>
				
				Однак тут є один суттєвий нюанс. Ці гріди не будуть безпосередньо вставлені в наш кореневий грід, в якому ви використали макрос list. Насправді, буде створений один вкладений грід з назвою cranes, а вже всередині нього 
				будуть вкладені гріди із списку з назвами 0, 1, 2 і так далі. Це можна порівняти із принципом влаштування даних в самому джаваскрипті: масив є водночас і об"єктом, який може містити також і довільні пари ключ-значення.
				Саме тому ми змінили адресацію до комірки multiplier на '^^/multiplier', що означає "слухати значення комірки multiplier із усіх батьківських грідів".
				
				
				<h3>
						Списки на основі даних з комірок
				</h3>
				Для того, щоб список cranes змінювався в процесі роботи програми, ми можемо зробити так:
				<code>
var cranes = [
	{
		width: 40,
		height: 120,
	},
	{
		width: 50,
		height: 80,
	},
	{
		width: 70,
		height: 160,
	},
]
var app = Firera({
	__root: {
		multiplier: 10,
		cranes: ['just', cranes],
		$child_cranes: ['list', {
			type: 'crane',
			datasource: ['../cranes'], 
		}]
	},
	crane: {
		weight: [(w, h, m) => {
			return (w+h)/m;
		}, 'width', 'height', '^^/multiplier']
	}
});

console.log(app.get('weight', '/cranes/0')); // 16
console.log(app.get('height', '/cranes/0')); // 120

console.log(app.get('weight', '/cranes/1')); // 13
console.log(app.get('height', '/cranes/1')); // 80

console.log(app.get('weight', '/cranes/2')); // 23
console.log(app.get('height', '/cranes/2')); // 160

cranes.push({
	width: 100,
	height: 100,
})

cranes[1].weight = 60;

app.set('cranes', cranes);

console.log(app.get('weight', '/cranes/3')); // 100
console.log(app.get('height', '/cranes/3')); // 

console.log(app.get('weight', '/cranes/1')); // 60

</code>
				Ключовою тут є строчка: datasource: ['../cranes']
				Якщо при використанні параметру data ми передаємо туди масив, то у випадку з datasource ми можемо використовувати повноцінні F-вирази.
				Тепер, якщо ми змінимо значення комірки cranes, зміни будуть внесені і в наші гріди!
			
				
				
					
			</div>
		</div>
			<script>
					$(document).ready(function() {
							$('code').each(function(i, block) {
									hljs.highlightBlock(block);
							});
					});
			</script>
		</body>
</html>
