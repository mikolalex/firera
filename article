F - это реактивная библиотека для фронтенда, представляющая свой оригинальный синтаксис для описания взаимозависимостей в состоянии через чистые функции. Ее можно использовать с любым подходящим шаблонизатором,  или даже вообще без оного, просто на готовом ХТМЛ документе, как jQuery, по старинке(удобно для небольших задач). Существует также отдельная версия F для реакта, имеющая аналогичный синтаксис, которая называется mrr(что означает make react reactive), о ней будет отдельный разговор. В комплекте с библиотекой идет свой шаблонизатор Ozenfant, сегодняшние примеры будут рассматриваться на нем. Он тоже выглядит немного… странно, хотя если вы видели Jade/Pug, то сильно удивляться не будете.
// "grid"(решетка) - структура, описывающая взаимосвязь потоков данных в приложении
const grid = {
    // корневой компонент
    $root: {
        // блок начальных значений ячеек
        $init: {
        	// корневой ДОМ узел
			$el: document.querySelector("#fr-app"),
            a: 0,
            b: 0,
			// Ozenfant-шаблон компонента
			$template: `
				.calc
					input(type: text, name: a)
					" + "
					input(type: text, name: b)
					" = "
					input(type: text, name: c, value: $c)	
			`,
        },
        // ячейка “а” будет просто дублировать ячейку “input[name=a]|getval”
        a: 'input[name=a]|getval',
        b: 'input[name=b]|getval',
        // ячейка “с” высчитывается подставлением в функцию значений ячеек “a” и “b”
        c: [(n, m) => Number(n) + Number(m), 'a', 'b'],
    }, 
	// подключаем пакеты для работы с DOM
    $packages: ['htmlCells', 'ozenfant']
}
const app = Firera(grid);



В двух словах о синтаксисе Ozenfant: вложенность хтмл блоков определяется отступами, узел обозначается подобно CSS-селектору: имя тега и класс, напр., ul.goods. Просто точка означает тег по умолчанию, обычно это div(а вот внутри select’а это будет option). И аттрибуты тега, и inline-стили пишуться одинаково, в скобках. Текст нужно брать в кавычки.
Ячейки a и b будут получать данные из input полей, а ячейка c - подставляя значения ячеек a и b в "формулу"(функция (n, m) => Number(n) + Number(m)), когда они будут изменяться.
Пока ничего особенного, но уже можно отметить:
1) состояние ячеек высчитывается с помощью чистых функций
2) декларативная подписка на внешние источники данных(в данном случае, события DOM). Да, "input[name=a]|val" - это просто имя ячейки, но поскольку оно соответствует определенному паттерну, эта ячейка будет автоматически получать данные. Ячейка же "a" просто повторяет эти значения, служит удобным алиасом.
Попробуем что-то чуть более сложное, чтобы прочувствовать последствия такого подхода.
Возьмем для примера список товаров с фильтрацией(такой пример приводился в статье о библиотеке $mol, также реактивной, но не функционально- , а объектно-)

// наш список товаров
const goods = [ … ];
// количество товаров на странице
const perpage = 30;
const $template = `
.
	h1
		“Goods”
	.
		.
			select(name: category)
				.
					“Photo”
				.
					“Audio”
				.
					“Cars”
		.
			select(name: sort)
				.
					“Price”
				.
					“Name”
	ul.goods{$goods_on_current_page}
		.item
			.name$@name
			.price$@price
		
	ul.paging{$pages}
		.(data-page: $.)$@

`;
// Секция “чистые функции”, которые будут использоваться в приложении
const filter = field => (coll, field_val) => field_val ? coll.filter(item =>  item[field] === field_val) : coll;
const sort = (field, coll) =>  coll.sort((a, b) => a > b ? 1 : (a == b ? 0 : -1));
const page_slice = perpage => (coll, page) => coll.slice((page - 1)*perpage, page*perpage)’;
const count_pages = perpage => totalnum => Math.ceil(totalnum/perpage);

// Собственно само приложение
var app = Firera({
	$init: {
		goods,
		$template
	}
	page: [‘.paging > *|click|attr(data-page)’],
	selected_filter: [‘select[name=category]|getval’],
	filtered_goods: [filter(‘category’), ‘goods’, ‘selected_filter’],
	page_num: [count_pages(perpage), ‘filtered_goods’],
	pages: [(pagenum) => new Array(pagenum), ‘page_num’],
	sorted_goods: [sort, ‘filtered_goods’, ‘select[name=sort]|getval’],
	goods_on_current_page: [page_slice(perpage), ‘sorted_goods’, ‘page’]
})

Еще немного синтаксиса Ozenfant:
ul.goods{$goods_on_current_page} - итерирование вложенного блока по массиву goods_on_current_page, внутри него .name$@name - здесь @ означает ссылку на текущий элемент списка, по которому в данный момент проходит итерация.

Прослеживается четкое разделение: набор чистых функций преобразования данных без учета состояния, и плотный блок с описанием взаимозависимостей в состоянии.

Однако, описать реальное приложение только с помощью таких простых взаимосвязей не выйдет, ведь приходится работать с сайд-эффектами, на фротнэнде это, в первую очередь, работа с ДОМ и аджакс-запросы.
Изменять ДОМ в формулах конечно же не придется, архаичные времена ручной работы с ДОМом миновали, все заботы об обновлении ДОМа в соответствии с состоянием приложения берет на себя Ozenfant. 
А для асинхронного вычисления значения ячейки в Ф. есть специальный тип ячейки, и называется он... async.

Типы ячеек. Тип async.

Изменим наш код чтобы получать список товаров с бекенда.

var app = Firera({
	$init: {
		goods: [],
		$template
	}
	goods: ['async', (cb) => fetch('/goods').then(cb), '$start'],
	page: [‘.paging > *|click|attr(data-page)’],
	selected_filter: [‘select[name=category]|getval’],
	filtered_goods: [filter(‘category’), ‘goods’, ‘selected_filter’],
	page_num: [count_pages(perpage), ‘filtered_goods’],
	pages: [(pagenum) => new Array(pagenum), ‘page_num’],
	sorted_goods: [sort, ‘filtered_goods’, ‘select[name=sort]|getval’],
	goods_on_current_page: [page_slice(perpage), ‘sorted_goods’, ‘page’]
})

Vы указываем специальный тип ячейки "async", особенностью которого является то, что первым аргументом в формулу всегда передается функция-колбек, которую нужно использоваться для возврата результата. $start - специальная ячейка, значение по которой "протекает" лишь раз, после инициализации, таким образом
ее удобно использовать для одноразовых действий.
Уйти полностью от сайд-эффекта мы не можем, но Ф позволяет максимально изолировать его от выполнения "чистых" вычислений.
Сейчас мы пытаемся сразу получить весь список товаров, что в реальных условиях не стоит делать. Стоит передавать номер страницы в запросе, чтобы получать только нужную часть списка, а также выбранную категорию и сортировку.

var app = Firera({
	$init: {
		goods: [],
		$template
	}
	goods: ['async', (cb, page, category) => fetch('/goods?p=' + page + '&category=' + category).then(cb), 'page', 'selected_filter', '$start'],
	page: [‘.paging > *|click|attr(data-page)’],
	selected_filter: ‘select[name=category]|getval’,
	goods_on_current_page: ‘goods’
})

Если уж пойти по пути полного сокращения, то можно убрать ячейки-алиасы:
var app = Firera({
	$init: {
		goods_on_current_page: [],
		$template
	}
	goods_on_current_page: [
		'async', 
		(cb, page, category) => fetch('/goods?p=' + (page || 1) + '&category=' + (category || '')).then(cb), 
		‘.paging > *|click|attr(data-page)’, 
		‘select[name=category]|getval’, 
		'$start'
	],
})

Таким образом, вся логика уместилась в одну строчку, довольно длинную, но вполне читабельную.

Тип closure.

Наши функции-формулы не запоминают состояние, а просто преобразовывают одни данные в другие(пусть и асинхронно), ничего "не помня" о предыдущих вычислениях.
Наверное, многие уже почувствовали, чем опасен наш код с запросом товаров: более ранний запрос может завершиться позже, и таким образом старые данные перекроют новые.
Попытаемся решить эту проблему с помощью особого типа ячейки - closure, который позволяет сохранять локальные данные между вызовами формулы с помощью замыкания. Мы используем этот тип в связке с уже знакомым типом async, т.к. типы ячеек в Ф не взаимоисключающи, их можно комбинировать.
Наша задача - перед созданием нового ajax запроса проверять, не завершился ли предыдущий, и если нет, то обрывать его(abort)(поскольку на сегодняшний день нет API для обрыва запроса сделанного через fetch, в примере использована воображаемая функция makeXHR - обертка над XMLHttpRequest).


goods_on_current_page: [
	'asyncClosure', 
	() => {	
		let active_request;
		return function(cb, page, category){
			if(active_request){
				active_request.abort();
			}
			active_request = makeXHR('/goods?p=' + (page || 1) + '&category=' + (category || ''), cb);
		}
	}, 
	‘.paging > *|click|attr(data-page)’, 
	‘select[name=category]|getval’, 
	'$start'
],

Достаточно простой и выразительный код: мы храним текущий запрос в замыкании, как только приходит новый, мы отменяем предыдущий.
Тип closure позволяет безопасно сохранять некоторые данные между вычислениями, не нарушая общую детерминированность вычислений.

Тип nested.

Такой способ хорош для идемпотентных запросов, но совершенно непригоден, например, в случае отправки формы регистрации нового пользователя на сайте.
На время выполнения запросов, изменяющих состояние сервера, мы должны блокировать интерфейс и не позволять пользователю отправить новый запрос.
То есть, наша формула должна возращать результат запроса и еще параллельно отслеживать его состояние. Тут нам поможет третий тип ячеек - nested, 
позволяющий одной формуле возвращать значения в несколько подъячеек. Например:

// высчитываем сумму, произведение и наименьшее общее кратное двух чисел, раскладывая результаты вычислений в разные подъячейки(НОК вычисляется асинхронно)
result: ['nested', (cb, a, b) => {
    // отправляем данные в подъячейку "sum"
    cb('sum', a + b);
    cb('product', a * b);
    // подсчитаем НОК на сервере ;)
    makeXHR('/get_lcm.php?a=' + a + '&b=' + b, (data) => {
        cb('lcm', data);
    })
}, '.a|getval', '.b|getval'],
// изве подъячейка доступна по шаблону "имя ячейки"."имя подъячейки"
message: [a => 'Least common multiple is ' + a, 'result.lcm'],
$template: `
    .
        input.a
        input.b
        .$message

`

Ячейка result является как бы общим namespace'ом для нескольких отдельных подъячеек. Как и в типе async, в формулу передается колбек, но, вызывая его, мы указываем
не только результат, но и имя подъячейки, в которую нужно его "положить". Подъячейки независимы друг от друга, на них можно подписываться
как и на любые другие обычные ячейки.

Тепер мы может разделить состояние запроса(выполняется/нет) и данные, которые приходят в его результате.

$init: {
    message: '',
	$template: `

	.
		h2
			"Register"
		form
			.
				input(name: login)
			.
				password(name: password)
			.
				submit(disabled: $register_user_request.loading)
		.$message


	`
},
register_user_request: [
	'nested',
	function(cb, login, password){
		cb('loading', true);
		makeXHR('/goods?p=' + (page || 1) + '&category=' + (category || ''), (data) => {
			cb('loading', false);
			cb('data', data);
		});
	},
	‘[name=login]|getval’, 
	‘[name=password]|getval’
],
message: [(res) => res.success ? 'You\'ve been successfully registered!' : 'Registration failed', 'register_user_request.data'],
(password - алиас для input(type: password), аналогично submit, checkbox и т.п.)

Тип funnel. Сигналы.

Допустим, у нас есть некоторое модальное окно(попап). По клику на кнопку мы должны показать его, по клику на крестик(и, возможно, вследствие также некоторых других действий) - скрыть. Привыкнув думать императивно, мы сразу выстраиваем цепочку: обработчик клика, затем вызов функции, изменяющей состояние переменной, от которой зависит видимость попапа. Для закрывания попапа - аналогично: обрабочик, изменение состояния видимости в false. Шаблон нашего мышления в исперативной парадигме таков: "Какие последствия вызовет данная причина?"
В декларативном же подходе мы должны думать наоборот: "При каких условиях возникает то или иное состояние?".
Мы должны создать единую ячейку, отвечающую за видимость попапа, и описать ее зависимости от других ячеек.
Наивная попытка могла бы выглядеть так:
$init: { 
	$template: `
		.
		h1
			"Hello!"
		.popups
			? $popup_shown
				.popup
					.close
						"Close"
					h2
						"Please login"
					.text(placeholder: Login)
					.password(placeholder: Password)
		.content
			button.show-popup
			"Login"
	`,
}
popup_shown: [(a, b) => {
    // ...ыыыы?
}, '.show-popup|click', '.popup .close|click']

Конструкция вида
? condition
	.foo
:
	.bar
в Ozenfant отвечает за ветвление, синтаксис аналогичен тернарному выражению в джс.		
И при клике на .show-popup, и при клике на .popup .close будет производиться пересчет значения ячейки popup_shown, однако как понять, что же нам делать?
Для того, чтобы знать, какой из аргументов изменился, существует тип funnel. Его особенность в том, что в формулу передаются не все значения ячеек-аргументов, а только имя и значение той ячейки, которая изменилась.

popup_shown: ['funnel', (cell, val) => {
    if(cell === '.show-popup|click'){
		return true;
    } else {
		return false;
    }
    // ...ыыыы?
}, '.show-popup|click', '.popup .close|click']

Таким образом мы можем оперативно реагировать на изменения родительских ячеек.
Существует синтаксический сахар для подобный конструкций - map:

popup_shown: ['map', {
    '.show-popup|click': true, 
    '.popup .close|click': false,
    ...
    'login_request.success': (val) => {
		// можно также фильтровать значение родительской ячейки
		return val;
    },
}]

Вот так красиво, деклративно мы можем описывать состояние нашего приложения.
Вместо сотен операторов Rx, все возникающие ситуации можно свести к комбинациям четырех типов.
Для наиболее распостраненных случаев есть сокращенные варианты, которые обеспечиваются механизмом макросов.

Макросы.
Упомянутая выше конструкция map является одним из примеров макроса. В Ф. макрос - это, по сути, чистая функция, преобразующая переданное ей значение в валидное выражение Ф(использующее один из 4 типов). Например, следующий код немного громоздок:
goods: ['async', (cb) => fetch('/goods').then(cb), '$start'],

Чтобы лаконично обрабатывать промисы, создадим свой макрос(с именем promise):
// на вход макрос получает исходное выражение
promise: ([func, ...cells]) => {
    // макрос возвращает новое выражение, сводя его к типу async
    return ['async', (cb, ...args) => {
		// выполняем формулу с аргументами и затем вызываем колбек
		func.apply(null, args).then(res => cb(res));
    }, ...cells];
}
Используя данный макрос, мы можем сделать наш код немного красивее:
goods: ['promise', () => fetch('/goods'), '$start'],

Макросы в Ф - синтаксический сахар, упрощающий разработку. Существует набор стандартных макросов, поставляемых вместе с библиотекой, кроме того, вы можете добавлять свои пользовательские макросы.

 

















